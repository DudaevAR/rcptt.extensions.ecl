*** Custom commands overview
This repository is a complete example on how to create a custom [[http://github.com/xored/ecl][ECL]] command and use it in [[http://www.xored.com/products/q7/][Q7]].


The challenge with custom ECL commands is that they should be executed inside an application under test, therefore they have to be installed into it. However making a custom build for tests or including these extra plug-ins and dependencies into a final product is not desired. As a solution, Q7 has mechanism to automatically include extra dependencies into an application-under-test -- in Q7 runner this can be done via [[http://help.xored.com/display/Q7/Q7+Runner#Q7Runner-Injectionoptions][injections]], and in Q7 IDE this can be done by wrapping an update site into a special plug-in, which can be installed into Q7 IDE itself.

This example shows a sample Maven build, which allows to build a runtime update site for Q7 Runner and update site for Q7 IDE in a single Tycho build, and can be used as a starting point for creating custom application-specific commands.

As an example, we create a custom ECL command *get-problem-messages* which returns all error messages from Problems view (more precisely, it searches for all resource markers with type 'problemmarker' and gets and error messages from them).

Combined with other ECL commands, this command can be used to assert that there are no errors in Problems view, like this:

#+BEGIN_SRC none
get-problem-messages | length | eq 0 | assert-true "There are build problems"
#+END_SRC

Or it can be used to assert that a Problems view contains a certain message:
#+BEGIN_SRC none
// here we use 'foreach' as a filter --
// it returns only those elements, which match
// to a condition inside an 'if' statement
get-problem-messages | foreach [val msg] {
	if [$msg | invoke contains "Foo cannot be resolved to a type"] {
		$msg
	}
} | length | gt 0 | assert-true "Expected problem not found"
#+END_SRC

*** Structure

A custom command is split into two plug-ins:
- *com.xored.q7.extensions.ecl.model*, which holds a EMF model for a command
- *com.xored.q7.extensions.ecl.impl*, which contains a Java implementation for a command

This separation is not strictly required, but very convenient -- in case of a custom application-specific ECL command only an implementation plugin has a dependency on an application plug-ins, so model plug-in can be added to Q7 IDE in order to provide completion and documentation.

A repository is structured as following:
- *common*
  - plug-in with a command model
  - feature, which consists of this plug-in only
- *runtime*
  - plug-in with a command implementation
  - feature, which includes implementation plug-in and a common feature
  - repository, which provides runtime feature
- *ide*
  - plug-in, which holds a binary runtime repository (it is automatically copied inside a plug-in during maven build)
  - feature, which includes ide plug-in and a common feature
  - repository, which provides IDE feature
- *q7tests* contains sample Q7 Maven plug-in, which 'installs' all features runtime repository into application-under-test

*** Usage
    Use =mvn clean install= in repository root to build Runtime and IDE update sites. After that IDE update site can be installed into Q7 from =ide/repository/com.xored.q7.extensions.ide.site/target/repository=. Note that for optimization purposes Q7 IDE does not check for new injections for existing AUTs (issue [[http://jira4.xored.com/browse/QS-3019][QS-3019]]), so it is required to remove and add back an AUT in Q7 after installing/updating Q7 IDE extensions.

    Use =mvn clean istall= in =q7tests= folder to run sample test cases using custom command.
